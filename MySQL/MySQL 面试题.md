# MySQL 面试题



注意：这是专为面试准备的，力求简洁，有深度。一定要简介，负责会臃肿不堪。



## MySQL 有哪些存储引擎？



### 存储引擎简介

MySQL中的数据用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。



### InnoDB

- 【最重要】支持事务。
- 支持行级锁和表级锁，能支持更多的并发量。
- ~~查询不加锁，完全不影响查询。~~
- 支持崩溃后恢复。





### MyISAM

- 不支持事务。
- 使用表级锁，如果数据量大，一个插入操作锁定表后，其他请求都将阻塞。



#### 存储

每个`MyISAM`表都以两个文件的形式存储在磁盘上。这些文件的名称以表名开头，并具有指示文件类型的扩展名。数据文件具有 `.MYD`( `MYData`) 扩展名。索引文件具有`.MYI` ( `MYIndex`) 扩展名。



#### **MyISAM** 存储引擎特征

| 特征         | 支持 |
| ------------ | ---- |
| **聚集索引** | 不   |
| **B 树索引** | 是   |
| **锁定粒度** | 表   |
| **事务**     | 不   |



- **加锁并发**

MyISAM 对张表加锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。但是在表有读取查询的同时，也可以往表中插入新的记录（这被称为并发插入）

> 并发插入
>
> 存储`MyISAM`引擎支持并发插入，以减少给定表的读取者和写入者之间的争用：如果表`MyISAM`在数据文件中没有空洞（中间删除了行），则 [`INSERT`](https://dev.mysql.com/doc/refman/8.0/en/insert.html)可以执行语句将行添加到表的末尾同时该 [`SELECT`](https://dev.mysql.com/doc/refman/8.0/en/select.html)语句从表中读取行。如果有多个 [`INSERT`](https://dev.mysql.com/doc/refman/8.0/en/insert.html)语句，它们将排队并按顺序执行，与 [`SELECT`](https://dev.mysql.com/doc/refman/8.0/en/select.html)语句同时执行。并发的结果[`INSERT`](https://dev.mysql.com/doc/refman/8.0/en/insert.html)可能不会立即可见。



- **修复**

对于MyISAM表，MySQL可以手工或者自动执行检查和修复操作，但这里说的修复和事务恢复以及崩溃恢复是不同的概念。执行表的修复可能导致一些数据丢失。





## 事务

事务只是一个改变，是一些的操作集合；用专业的术语去解释，就是一个程序的执行单元；事务本身并不包含这四个特性，我们需要通过某些手段，尽可能让这个执行单元满足这四个特性，那么，我们就可以称它是一个事务，或者说是一个正确的，完美的事务。



### ACID

在关系型数据库中，事务具有 ACID 四个基本属性。数据库事务的 ACID 四大特性是事务的基础，了解了 ACID 是如何实现的，我们也就清楚了事务的实现。



#### 原子性（Atomicity）

一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。



##### 回滚日志

想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行**回滚**，而在 MySQL 中，恢复机制是通过*回滚日志*（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。

![Transaction-Undo-Log](MySQL 面试题.assets/2017-08-20-Transaction-Undo-Log.jpg-1000width)

这个过程其实非常好理解，为了能够在发生错误时撤销之前的全部操作，肯定是需要将之前的操作都记录下来的，这样在发生错误时才可以回滚。

回滚日志除了能够在发生错误或者用户执行 `ROLLBACK` 时提供回滚相关的信息，它还能够在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后写数据库的主要原因。

回滚日志并不能将数据库物理地恢复到执行语句或者事务之前的样子；它是逻辑日志，当回滚日志被使用时，它只会按照日志**逻辑地**将数据库中的修改撤销掉看，可以**理解**为，我们在事务中使用的每一条 `INSERT` 都对应了一条 `DELETE`，每一条 `UPDATE` 也都对应一条相反的 `UPDATE` 语句。

![Logical-Undo-Log](MySQL 面试题.assets/2017-08-20-Logical-Undo-Log.jpg-1000width)





#### 一致性（Consistency）


数据库总是从一个一致性的状态转换到另外一个一致性的状态。



#### 隔离性(isolation)

通常来说，一个事务所作的修改在最终提交以前，对其他事务是不可见的。后面我们讨论隔离级别的时候，会发现为什么我们说“通常来说”是不可见的。



##### 隔离级别的实现

数据库对于隔离级别的实现就是使用**并发控制机制**对在同一时间执行的事务进行控制，限制不同的事务对于同一资源的访问和更新。



#### 持久性（durability）

一旦事务提交，则其所作的修改就会永久保存到数据库中。即使此时系统崩溃，修改的数据也不会丢失。



##### 重做日志

与原子性一样，事务的持久性也是通过日志来实现的，MySQL 使用重做日志（redo log）实现事务的持久性，重做日志由两部分组成，一是内存中的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。

![Redo-Logging](MySQL 面试题.assets/2019-02-21-Redo-Logging.jpg)

当我们在一个事务中尝试对数据进行修改时，它会先将数据从磁盘读入内存，并更新内存中缓存的数据，然后生成一条重做日志并写入重做日志缓存，当事务真正提交时，MySQL 会将重做日志缓存中的内容刷新到重做日志文件，再将内存中的数据更新到磁盘上，图中的第 4、5 步就是在事务提交时执行的。

在 InnoDB 中，重做日志都是以 512 字节的块的形式进行存储的，同时因为块的大小与磁盘扇区大小相同，所以重做日志的写入可以保证原子性，不会由于机器断电导致重做日志仅写入一半并留下脏数据。

除了所有对数据库的修改会产生重做日志，因为回滚日志也是需要持久存储的，它们也会创建对应的重做日志，在发生错误后，数据库重启时会从重做日志中找出未被更新到数据库磁盘中的日志重新执行以满足事务的持久性。







### 隔离级别



#### 并发情况下事务引发的问题

> 一般情况下，多个单元操作（事务，这里的事务，并不是完美的事务）并发执行，会出现这么几个问题：

- 脏读：A事务还未提交，B事务就读到了A操作的结果。（破坏了隔离性）
- 不可重复读：A事务在本次事务中，对自己未操作过数据，进行多次读取，结果出现不一致或记录不存在的情况。（破坏了一致性，重点是update和delete）
- 幻读：A事务在本次事务中，先读取了一遍数据，发现数据不存在，过了一会，又读取了一遍，发现又有数据了。（破坏了一致性，重点是insert）



#### 解决（制定标准）

为了权衡『隔离』和『并发』的矛盾，ISO定义了4个事务隔离级别，每个级别隔离程度不同，允许出现的副作用也不同。

- 未提交读（read-uncommitted）：最低级别，基本只保证持久性；会出现脏读，不可重复读，幻读的问题。
- 已提交读（read-committed）：语句级别；会出现不可重复读，幻读的问题。
- 可重复读（repeatable-read）：事务级别；只会出现幻读问题。
- 串行化（serializable）：最高级别，也就是事务与事务完全串行化执行，无并发可言，性能低；但不会出现任何问题。

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---- | ---------- | ---- |
| 读未提交（read-uncommitted） | 会   | 会         | 会   |
| 不可重复读（read-committed） | -    | 会         | 会   |
| 可重复读（repeatable-read）  | -    | -          | 会   |
| 串行化（serializable）       | -    | -          | -    |

注意：这四个级别只是一个标准，各个数据库厂商，并不完全按照标准做的。



#### 实现（InnoDB）

- 锁机制：阻止其他事务对数据进行操作， 各个隔离级别主要体现在读取数据时加的锁的释放时机。
  - RU：事务读取时不加锁
  - RC：事务读取时加行级共享锁（读到才加锁），一旦读完，立刻释放（并不是事务结束）。
  - RR：事务读取时加行级共享锁，直到事务结束时，才会释放。
  - SE：事务读取时加表级共享锁，直到事务结束时，才会释放。

- MVCC机制：生成一个数据快照，并用这个快照来提供一定级别的一致性读取，也称为多版本数据控制。
  - 实际就是『版本控制』加『读写分离』思想，主要用作于RC和RR级别。
  - 这里面就太细了，主要涉及到事务原理和索引，就不讲了，因为！第一：面试要求讲MVCC的原理比较少，第二：主要我讲了你必然记不住，这也是为什么问的比较少的原因了，因为面试官自己肯定是记不住的。除非像在下一样，每天每天的看，感觉忘了就看。一般人也做不到。如果面试被问到了，肯定是面试官上班无聊，刷到一些软文，自己看了看，觉得写得很好，随口就问了。

## 复制