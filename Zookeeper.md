# Zookeeper



## Zookeeper 是什么



ZooKeeper 是一个开放源码的分布式协调服务，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。

分布式应用程序可以基于Zookeeper实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。

Zookeeper具有如下特性：

- 顺序一致性（有序性）

  >从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到 Zookeeper 中去。
  >
  >有序性是 Zookeeper 中非常重要的一个特性。
  >
  >- 所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为zxid(Zookeeper Transaction Id)。
  >- 而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个 Zookeeper 最新的 zxid 。

- 原子性

  >所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，即整个集群要么都成功应用了某个事务，要么都没有应用。

- 单一视图

  >无论客户端连接的是哪个 Zookeeper 服务器，其看到的服务端数据模型都是一致的。

- 可靠性

  >一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会一直被保留，除非有另一个事务对其进行了变更。

- 实时性

  >Zookeeper 保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。



Zookeeper 对于读写请求有所不同：

- 客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的 Zookeeper 机器来处理。
- 对于写请求，这些请求会同时发给其他 Zookeeper 机器并且达成一致后，请求才会返回成功。因此，随着 Zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。





## Zookeeper 的设计目标



1. 简单的数据结构，Zookeeper 使得分布式程序能够通过一个共享的树形结构的名字空间来进行相互协调，即 Zookeeper 服务器内存中的数据模型由一系列被称为 ZNode 的数据节点组成，Zookeeper 将全量的数据存储在内存中，以此来提高服务器吞吐、减少延迟的目的。
2. 可以构建集群 Zookeeper 集群通常由一组机器构成，组成 Zookeeper 集群的而每台机器都会在内存中维护当前服务器状态，并且每台机器之间都相互通信。
3. 顺序访问，对于来自客户端的每个更新请求，Zookeeper 都会分配一个全局唯一的递增编号，这个编号反映了所有事务操作的先后顺序。
4. 高性能，Zookeeper 和 Redis 一样全量数据存储在内存中，100%读请求压测 QPS 12-13W 。





## Zookeeper 有哪些应用场景



Zookeeper 的功能很强大，应用场景很多，结合我们实际工作中使用 Dubbo 框架的情况，Zookeeper 主要是做注册中心用。

- 基于 Dubbo 框架开发的提供者、消费者都向 Zookeeper 注册自己的 URL ，消费者还能拿到并订阅提供者的注册 URL ，以便在后续程序的执行中去调用提供者。
- 而提供者发生了变动，也会通过 Zookeeper 向订阅的消费者发送通知。

当然，Zookeeper 能提供的不仅仅如此，再例如：



- 统一命名服务。

  >命名服务是指通过指定的名字来获取资源或服务的地址，利用zk创建一个全局的路径，即时唯一的路径，这个路径就可以作为一个名字，指向集群中机器或者提供服务的地址，又或者一个远程的对象等。

- 分布式锁服务。

  >这个比较好理解，Zookeeper 实现的分布式锁的可靠性会比 Redis 实现的分布式锁高，当然相对来说，性能会低。

- 配置管理。

  >例如说，[Spring Cloud Config Zookeeper](https://blog.csdn.net/CSDN_Stephen/article/details/78856323) ，就实现了基于 Zookeeper 的 Spring Cloud Config 的实现，提供配置中心的服务。

- 注册与发现。

  >是否有机器加入或退出
  >
  >所有机器约定在父目录下创建临时目录节点，然后监听父目录节点下的子节点变化。一旦有机器挂掉，该机器与 ZooKeeper 的连接断开，其所创建的临时目录节点也被删除，所有其他机器都收到通知：某个节点被删除了。

- Master 选举。

  >基于 Zookeeper 实现分布式协调，从而实现主从的选举。这个在 Kafka、Elastic-Job 等等中间件，都有所使用到。

- 分布式锁。

  >有了 ZooKeeper 的一致性文件系统，锁的问题变得容易。锁服务可以分成两类，一个是保持独占，另一个是控制时序。
  >
  >- 1、保持独占，我们把 znode 看作是一把锁，通过 createZnode 的方式来实现。所有客户端都去创建 `/distribute_lock` 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的 `/distribute_lock` 节点就释放出锁。
  >- 2、控制时序，`/distribute_lock` 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和 Master 一样，编号最小的获得锁，用完删除，依次方便。

- 队列管理

  >两种类型的队列。
  >
  >- 1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待。在约定的目录下创建临时目录节点，监听节点数目是否是我们要求的数目。
  >- 2、队列按照 FIFO 方式进行入队和出队操作。和分布式锁服务中的控制时序的场景基本原理一致，入列有编号，出列按编号。创建 PERSISTENT_SEQUENTIAL 节点，创建成功时 Watcher 通知等待的队列，队列删除序列号最小的节点以消费。此场景下，znode 用于消息存储，znode 存储的数据就是消息队列中的消息内容，SEQUENTIAL 序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以不必担心队列消息丢失的问题。







## ~~作为服务注册中心，Eureka 比 Zookeeper 好在哪里~~



比较重要的原因是，注册中心对可用性比一致性有更高的要求，也就是说，能够容忍在异常情况下，读取到几分钟前的数据。



## Zookeeper 提供了什么



- 文件系统。
- 通知机制。



## Zookeeper 的文件系统是什么



Zookeeper 提供一个多层级的节点命名空间(节点称为 znode)。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。

Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为 1M 。



###  **Zookeeper 有哪几种节点类型**



- PERSISTENT 持久节点

  > 创建之后一直存在，除非有删除操作，创建节点的客户端会话失效也不影响此节点。

- PERSISTENT_SEQUENTIAL 持久顺序节点

  > 跟持久一样，就是父节点在创建下一级子节点的时候，记录每个子节点创建的先后顺序，会给每个子节点名加上一个数字后缀。

- EPHEMERAL 临时节点

  > 创建客户端会话失效（注意是会话失效，不是连接断了），节点也就没了。不能建子节点。

- EPHEMERAL_SEQUENTIAL 临时顺序节点

  > 基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。



## ~~Zookeeper 的通知机制是什么~~



Zookeeper 允许客户端向服务端的某个 znode 注册一个 Watcher 监听，当服务端的一些指定事件触发了这个 Watcher ，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据 Watcher 通知状态和事件类型做出业务上的改变。

整个流程如下：

> 具体的过程，下面每个小问题，进行说明。

- 第一步，客户端注册 Watcher 。
- 第二步，服务端处理 Watcher 。
- 第三步，客户端回调 Watcher 。





## Zookeeper 的部署方式



Zookeeper 有两种部署方式：

- 1、单机
- 2、集群

>Zookeeper 集群，是一个由多个 Server 组成，一个 Leader，多个 Follower。（这个不同于我们常见的 Master/Slave 模式）Leader 为客户端服务器提供读写服务，除了 Leader 外其他的机器只能提供读服务。
>
>每个 Server 保存一份数据副本全数据一致，分布式读 Follower ，写由 Leader 实施更新请求转发，由 Leader 实施更新请求顺序进行，来自同一个 Client 的更新请求按其发送顺序依次执行数据更新原子性，一次数据更新要么成功，要么失败。
>
>全局唯一数据视图，Client 无论连接到哪个 Server，数据视图都是一致的实时性，在一定事件范围内，Client 能读到最新数据。
>
>![Zookeeper 集群](Zookeeper.assets/20cdb662c4f40297b3713148fdfd1c47)

**一般来说，测试环境部署单机，而生产环境必须必须必须部署集群。**





### **集群中的机器角色有哪些**



集群中一共有三种角色：

- 1、Leader

  > - 事务请求的唯一调度和处理者，保证集群事务处理的顺序性。
  > - 集群内部各服务的调度者。

- 2、Follower

  > - 处理客户端的非事务请求，转发事务请求给 Leader 服务器。
  > - 参与事务请求 Proposal 的投票。
  > - 参与 Leader 选举投票。

- 3、Observer





### **集群支持动态添加机器吗**



在 3.5 版本开始，支持动态扩容。

而在 3.5 版本之前，Zookeeper 在这方面不太好。所以需要如下两种方式：

- 全部重启：关闭所有 Zookeeper 服务，修改配置之后启动。不影响之前客户端的会话。
- 逐个重启：顾名思义。这是比较常用的方式。





###  **Zookeeper 下 Server 工作状态**



服务器具有四种状态，分别是：

- LOOKING 寻找 Leader 状态

  > 当服务器处于该状态时，它会认为当前集群中没有 Leader ，因此需要进入 Leader 选举状态。

- FOLLOWING 跟随者状态

  > 表明当前服务器角色是 Follower 。

- LEADING 领导者状态

  > 表明当前服务器角色是 Leader 。

- OBSERVING 观察者状态

  > 表明当前服务器角色是 Observer 。





## ZooKeeper 的工作原理



Zookeeper 的核心是原子广播，这个机制保证了各个Server 之间的同步。实现这个机制的协议叫做 **Zab** 协议。Zab 协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）：



- 选主：当服务启动或者 Leader 崩溃后，Zab 就进入了恢复模式，当新的 Leader 被选举出来，且大多数 Server 完成了和 Leader 的状态同步以后，恢复模式就结束了。

  >当整个 Zookeeper 集群刚刚启动，或者 Leader 服务器宕机、重启或者网络故障导致不存在过半的服务器与 Leader服务器保持正常通信时，所有进程（服务器）进入崩溃恢复模式。
  >
  >- 首先，选举产生新的Leader服务器。
  >- 然后，集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步。
  >- 当集群中超过半数机器与该Leader服务器完成数据同步之后，退出恢复模式进入消息广播模式，

- 同步：状态同步保证了 Leader 和 Server 具有相同的系统状态

  >Leader 服务器开始接收客户端的事务请求，生成事务提案来进行事务请求处理。



###  **ZooKeeper 是如何保证事务的顺序一致性的**



ZooKeeper 采用了递增的事务 id 来识别，所有的 proposal（提议）都在被提出的时候加上了 zxid 。zxid 实际上是一个 64 位数字。

- 高 32 位是 epoch 用来标识 Leader 是否发生了改变，如果有新的 Leader 产生出来，epoch会自增。
- 低 32 位用来递增计数。

当新产生的 peoposal 的时候，会依据数据库的两阶段过程，首先会向其他的 Server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。





###  **ZooKeeper 集群中个服务器之间是怎样通信的**



Leader 服务器会和每一个 Follower/Observer 服务器都建立 TCP 连接，同时为每个 Follower/Observer 都创建一个叫做 LearnerHandler 的实体。

- LearnerHandler 主要负责 Leader 和 Follower/Observer 之间的网络通讯，包括数据同步，请求转发和 Proposal 提议的投票等。
- Leader 服务器保存了所有 Follower/Observer 的 LearnerHandler 





### **ZAB 和 Paxos 算法的联系与区别**



Paxos 算法是分布式选举算法，Zookeeper 使用的 ZAB 协议（Zookeeper 原子广播）。

二者有相同的地方：

- 都有一个 Leader，用来协调 N 个 Follower 的运行
- Leader 要等待超半数的 Follower做 出正确反馈之后才进行提案。
- 二者都有一个值来代表 Leader 的周期。ZAB 协议中，每个 Proposal 中都包含一个 epoch 值来代表当前的Leader周期，Paxos中名字为 Ballot 。

不同的地方在于：

- ZAB 用来构建高可用的分布式数据主备系统（Zookeeper），Paxos 是用来构建分布式一致性状态机系统。





## ~~Zookeeper 的选举过程~~



当 Leader 崩溃，或者 Leader 失去大多数的 Follower，这时 Zookeeper 进入恢复模式，恢复模式需要重新选举出一个新的 Leader，让所有的 Server 都恢复到一个正确的状态。

Zookeeper 的选举算法有两种：一种是基于 basic paxos 实现的，另外一种是基于 fast paxos 算法实现的。系统默认的选举算法为 fast paxos 。





## Zookeeper 的同步流程



- 1、Leader 等待 Server 连接。
- 2、Follower 连接 Leader ，将最大的 zxid 发送给 Leader 。
- 3、Leader 根据 Follower 的 zxid 确定同步点。
- 4、完成同步后通知 Follower 已经成为 update 状态。
- 5、Follower 收到 update 消息后，又可以重新接受 Client 的请求进行服务了。